<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · NovaML.jl</title><meta name="title" content="API Reference · NovaML.jl"/><meta property="og:title" content="API Reference · NovaML.jl"/><meta property="twitter:title" content="API Reference · NovaML.jl"/><meta name="description" content="Documentation for NovaML.jl."/><meta property="og:description" content="Documentation for NovaML.jl."/><meta property="twitter:description" content="Documentation for NovaML.jl."/><meta property="og:url" content="https://ilkerarslan.github.io/NovaML.jl/stable/api/"/><meta property="twitter:url" content="https://ilkerarslan.github.io/NovaML.jl/stable/api/"/><link rel="canonical" href="https://ilkerarslan.github.io/NovaML.jl/stable/api/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXXXXXX-X"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-XXXXXXXXX-X', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NovaML.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../user_guide/getting_started/">Getting Started</a></li><li><a class="tocitem" href="../user_guide/core_concepts/">Core Concepts</a></li><li><a class="tocitem" href="../user_guide/preprocessing/">Data Preprocessing</a></li><li><a class="tocitem" href="../user_guide/model_training/">Model Training</a></li><li><a class="tocitem" href="../user_guide/model_evaluation/">Model Evaluation</a></li><li><a class="tocitem" href="../user_guide/feature_engineering/">Feature Engineering</a></li><li><a class="tocitem" href="../user_guide/pipelines/">Pipelines</a></li><li><a class="tocitem" href="../user_guide/hyperparameter_tuning/">Hyperparameter Tuning</a></li><li><a class="tocitem" href="../user_guide/cross_validation/">Cross-Validation</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../models/linear_models/">Linear Models</a></li><li><a class="tocitem" href="../models/tree_models/">Tree-Based Models</a></li><li><a class="tocitem" href="../models/ensemble_methods/">Ensemble Methods</a></li><li><a class="tocitem" href="../models/svm/">Support Vector Machines</a></li><li><a class="tocitem" href="../models/clustering/">Clustering</a></li><li><a class="tocitem" href="../models/dimensionality_reduction/">Dimensionality Reduction</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Datasets"><span>Datasets</span></a></li><li><a class="tocitem" href="#Clustering"><span>Clustering</span></a></li><li><a class="tocitem" href="#Decomposition"><span>Decomposition</span></a></li><li><a class="tocitem" href="#Ensemble-Methods"><span>Ensemble Methods</span></a></li></ul></li><li><a class="tocitem" href="../contribute/">Contributing</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ilkerarslan/NovaML.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ilkerarslan/NovaML.jl/blob/master/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Datasets"><a class="docs-heading-anchor" href="#Datasets">Datasets</a><a id="Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Datasets" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Datasets.load_boston-Tuple{}" href="#NovaML.Datasets.load_boston-Tuple{}"><code>NovaML.Datasets.load_boston</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_boston(; return_X_y=false)</code></pre><p>Load and return the Boston house prices dataset (regression).</p><p>This function creates a synthetic version of the Boston Housing dataset for demonstration purposes, as the original dataset might not be available.</p><p><strong>Arguments</strong></p><ul><li><code>return_X_y::Bool</code>: If true, returns <code>(X, y)</code> instead of a dict-like object.</li></ul><p><strong>Returns</strong></p><ul><li><p>If <code>return_X_y</code> is false, returns a Dict with the following keys:</p><ul><li>&quot;data&quot;: ndarray of shape (506, 13)   The data matrix.</li><li>&quot;target&quot;: ndarray of shape (506,)   The regression target.</li><li>&quot;feature_names&quot;: list   The names of the dataset columns.</li><li>&quot;DESCR&quot;: str   The full description of the dataset.</li></ul></li><li><p>If <code>return_X_y</code> is true, returns a tuple <code>(data, target)</code>:</p><ul><li>data : ndarray of shape (506, 13)</li><li>target : ndarray of shape (506,)</li></ul></li></ul><p><strong>Description</strong></p><p>The Boston Housing dataset contains information collected by the U.S Census Service concerning housing in the area of Boston Mass. It was obtained from the StatLib archive (http://lib.stat.cmu.edu/datasets/boston), and has been used extensively throughout the literature to benchmark algorithms.</p><p>Note: This function generates synthetic data based on the structure of the original Boston Housing dataset. The actual values and relationships in the data are simulated and do not represent real housing data.</p><p><strong>Features</strong></p><pre><code class="nohighlight hljs">1. CRIM: per capita crime rate by town
2. ZN: proportion of residential land zoned for lots over 25,000 sq.ft.
3. INDUS: proportion of non-retail business acres per town
4. CHAS: Charles River dummy variable (= 1 if tract bounds river; 0 otherwise)
5. NOX: nitric oxides concentration (parts per 10 million)
6. RM: average number of rooms per dwelling
7. AGE: proportion of owner-occupied units built prior to 1940
8. DIS: weighted distances to five Boston employment centres
9. RAD: index of accessibility to radial highways
10. TAX: full-value property-tax rate per $10,000
11. PTRATIO: pupil-teacher ratio by town
12. B: 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town
13. LSTAT: % lower status of the population</code></pre><p><strong>Target</strong></p><pre><code class="nohighlight hljs">- MEDV: Median value of owner-occupied homes in $1000&#39;s</code></pre><p><strong>Example</strong></p><p>```julia</p><p><strong>Load the Boston Housing dataset</strong></p><p>boston = load_boston()</p><p><strong>Access the data and target</strong></p><p>X = boston[&quot;data&quot;] y = boston[&quot;target&quot;]</p><p><strong>Get feature names</strong></p><p>feature<em>names = boston[&quot;feature</em>names&quot;]</p><p><strong>Alternatively, get data and target directly</strong></p><p>X, y = load<em>boston(return</em>X_y=true)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Datasets/BostonHousing.jl#L5-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Datasets.load_breast_cancer-Tuple{}" href="#NovaML.Datasets.load_breast_cancer-Tuple{}"><code>NovaML.Datasets.load_breast_cancer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_breast_cancer(; return_X_y=false)</code></pre><p>Load and return the Wisconsin Breast Cancer dataset (classification).</p><p><strong>Arguments</strong></p><ul><li><code>return_X_y::Bool</code>: If true, returns <code>(X, y)</code> instead of a dict-like object.</li></ul><p><strong>Returns</strong></p><ul><li><p>If <code>return_X_y</code> is false, returns a Dict with the following keys:</p><ul><li>&quot;data&quot;: Matrix{Float64} of shape (569, 30)   The data matrix.</li><li>&quot;target&quot;: Vector{Bool} of shape (569,)   The classification target.</li><li>&quot;feature_names&quot;: Vector{String}   The names of the dataset columns.</li><li>&quot;target_names&quot;: Vector{String}   The names of target classes.</li><li>&quot;DESCR&quot;: String   The full description of the dataset.</li></ul></li><li><p>If <code>return_X_y</code> is true, returns a tuple <code>(data, target)</code>:</p><ul><li>data: Matrix{Float64} of shape (569, 30)</li><li>target: Vector{Bool} of shape (569,)</li></ul></li></ul><p><strong>Description</strong></p><p>The Wisconsin Breast Cancer dataset is a classic and very easy binary classification dataset.</p><p><strong>Features</strong></p><p>Features are computed from a digitized image of a fine needle aspirate (FNA) of a breast mass.  They describe characteristics of the cell nuclei present in the image.</p><p>Ten real-valued features are computed for each cell nucleus:     1) radius (mean of distances from center to points on the perimeter)     2) texture (standard deviation of gray-scale values)     3) perimeter     4) area     5) smoothness (local variation in radius lengths)     6) compactness (perimeter^2 / area - 1.0)     7) concavity (severity of concave portions of the contour)     8) concave points (number of concave portions of the contour)     9) symmetry     10) fractal dimension (&quot;coastline approximation&quot; - 1)</p><p>The mean, standard error, and &quot;worst&quot; or largest (mean of the three largest values) of these features were computed for each image, resulting in 30 features.</p><p><strong>Target</strong></p><pre><code class="nohighlight hljs">- 0: benign
- 1: malignant</code></pre><p><strong>Dataset Characteristics</strong></p><pre><code class="nohighlight hljs">:Number of Instances: 569
:Number of Attributes: 30 numeric, predictive attributes and the class
:Attribute Information: 10 real-valued features are computed for each cell nucleus:
    a) radius (mean of distances from center to points on the perimeter)
    b) texture (standard deviation of gray-scale values)
    c) perimeter
    d) area
    e) smoothness (local variation in radius lengths)
    f) compactness (perimeter^2 / area - 1.0)
    g) concavity (severity of concave portions of the contour)
    h) concave points (number of concave portions of the contour)
    i) symmetry
    j) fractal dimension (&quot;coastline approximation&quot; - 1)

The mean, standard error, and &quot;worst&quot; or largest (mean of the three
largest values) of these features were computed for each image,
resulting in 30 features. For instance, field 3 is Mean Radius, field
13 is Radius SE, field 23 is Worst Radius.

:Class Distribution: 212 Malignant, 357 Benign</code></pre><p><strong>Example</strong></p><p>```julia</p><p><strong>Load the Breast Cancer dataset</strong></p><p>breast<em>cancer = load</em>breast_cancer()</p><p><strong>Access the data and target</strong></p><p>X = breast<em>cancer[&quot;data&quot;] y = breast</em>cancer[&quot;target&quot;]</p><p><strong>Get feature names and target names</strong></p><p>feature<em>names = breast</em>cancer[&quot;feature<em>names&quot;] target</em>names = breast<em>cancer[&quot;target</em>names&quot;]</p><p><strong>Alternatively, get data and target directly</strong></p><p>X, y = load<em>breast</em>cancer(return<em>X</em>y=true)</p><p><strong>Notes</strong></p><p>This function downloads the Wisconsin Breast Cancer dataset from the UCI Machine Learning Repository if it&#39;s not already present in the local directory.</p><p>The dataset was created by Dr. William H. Wolberg, W. Nick Street, and Olvi L. Mangasarian at the University of Wisconsin-Madison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Datasets/WisconsinBreastCancer.jl#L6-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Datasets.load_iris-Tuple{}" href="#NovaML.Datasets.load_iris-Tuple{}"><code>NovaML.Datasets.load_iris</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_iris(; return_X_y=false)</code></pre><p>Load and return the iris dataset (classification).</p><p><strong>Arguments</strong></p><ul><li><code>return_X_y::Bool</code>: If true, returns <code>(X, y)</code> instead of a dict-like object.</li></ul><p><strong>Returns</strong></p><ul><li><p>If <code>return_X_y</code> is false, returns a Dict with the following keys:</p><ul><li>&quot;data&quot;: Matrix{Float64} of shape (150, 4)   The data matrix.</li><li>&quot;target&quot;: Vector{Int} of shape (150,)   The classification target.</li><li>&quot;feature_names&quot;: Vector{String}   The names of the dataset columns.</li><li>&quot;target_names&quot;: Vector{String}   The names of target classes.</li><li>&quot;DESCR&quot;: String   The full description of the dataset.</li></ul></li><li><p>If <code>return_X_y</code> is true, returns a tuple <code>(data, target)</code>:</p><ul><li>data: Matrix{Float64} of shape (150, 4)</li><li>target: Vector{Int} of shape (150,)</li></ul></li></ul><p><strong>Description</strong></p><p>The iris dataset is a classic and very easy multi-class classification dataset.</p><p><strong>Features</strong></p><pre><code class="nohighlight hljs">1. sepal length (cm)
2. sepal width (cm)
3. petal length (cm)
4. petal width (cm)</code></pre><p><strong>Target</strong></p><pre><code class="nohighlight hljs">- Iris-setosa (1)
- Iris-versicolor (2)
- Iris-virginica (3)</code></pre><p><strong>Dataset Characteristics</strong></p><pre><code class="nohighlight hljs">:Number of Instances: 150 (50 in each of three classes)
:Number of Attributes: 4 numeric, predictive attributes and the class
:Attribute Information:
    - sepal length in cm
    - sepal width in cm
    - petal length in cm
    - petal width in cm
:Class:
    - Iris-Setosa
    - Iris-Versicolour
    - Iris-Virginica</code></pre><p><strong>Example</strong></p><p>```julia</p><p><strong>Load the Iris dataset</strong></p><p>iris = load_iris()</p><p><strong>Access the data and target</strong></p><p>X = iris[&quot;data&quot;] y = iris[&quot;target&quot;]</p><p><strong>Get feature names and target names</strong></p><p>feature<em>names = iris[&quot;feature</em>names&quot;] target<em>names = iris[&quot;target</em>names&quot;]</p><p><strong>Alternatively, get data and target directly</strong></p><p>X, y = load<em>iris(return</em>X_y=true)</p><p><strong>Notes</strong></p><p>This function downloads the Iris dataset from the UCI Machine Learning Repository if it&#39;s not already present in the local directory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Datasets/Iris.jl#L5-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Datasets.load_wine-Tuple{}" href="#NovaML.Datasets.load_wine-Tuple{}"><code>NovaML.Datasets.load_wine</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_wine(; return_X_y=false)</code></pre><p>Load and return the wine dataset (classification).</p><p><strong>Arguments</strong></p><ul><li><code>return_X_y::Bool</code>: If true, returns <code>(X, y)</code> instead of a dict-like object.</li></ul><p><strong>Returns</strong></p><ul><li><p>If <code>return_X_y</code> is false, returns a Dict with the following keys:</p><ul><li>&quot;data&quot;: Matrix{Float64} of shape (178, 13)   The data matrix.</li><li>&quot;target&quot;: Vector{Int} of shape (178,)   The classification target.</li><li>&quot;feature_names&quot;: Vector{String}   The names of the dataset columns.</li><li>&quot;target_names&quot;: Vector{String}   The names of target classes.</li><li>&quot;DESCR&quot;: String   The full description of the dataset.</li></ul></li><li><p>If <code>return_X_y</code> is true, returns a tuple <code>(data, target)</code>:</p><ul><li>data: Matrix{Float64} of shape (178, 13)</li><li>target: Vector{Int} of shape (178,)</li></ul></li></ul><p><strong>Description</strong></p><p>This dataset is a classic and very easy multi-class classification dataset.</p><p><strong>Features</strong></p><pre><code class="nohighlight hljs">1) Alcohol
2) Malic acid
3) Ash
4) Alcalinity of ash
5) Magnesium
6) Total phenols
7) Flavanoids
8) Nonflavanoid phenols
9) Proanthocyanins
10) Color intensity
11) Hue
12) OD280/OD315 of diluted wines
13) Proline</code></pre><p><strong>Target</strong></p><pre><code class="nohighlight hljs">- class 1 (0)
- class 2 (1)
- class 3 (2)</code></pre><p><strong>Dataset Characteristics</strong></p><pre><code class="nohighlight hljs">:Number of Instances: 178
:Number of Attributes: 13 numeric, predictive attributes and the class
:Attribute Information:
    - Alcohol
    - Malic acid
    - Ash
    - Alcalinity of ash
    - Magnesium
    - Total phenols
    - Flavanoids
    - Nonflavanoid phenols
    - Proanthocyanins
    - Color intensity
    - Hue
    - OD280/OD315 of diluted wines
    - Proline

:Class:
    - class 1
    - class 2
    - class 3</code></pre><p><strong>Example</strong></p><p>```julia</p><p><strong>Load the Wine dataset</strong></p><p>wine = load_wine()</p><p><strong>Access the data and target</strong></p><p>X = wine[&quot;data&quot;] y = wine[&quot;target&quot;]</p><p><strong>Get feature names and target names</strong></p><p>feature<em>names = wine[&quot;feature</em>names&quot;] target<em>names = wine[&quot;target</em>names&quot;]</p><p><strong>Alternatively, get data and target directly</strong></p><p>X, y = load<em>wine(return</em>X_y=true)</p><p><strong>Notes</strong></p><p>This function downloads the Wine dataset from the UCI Machine Learning Repository if it&#39;s not already present in the local directory.</p><p>The data set contains the results of a chemical analysis of wines grown in a specific area of Italy. Three types of wine are represented in the 178 samples, with the results of 13 chemical analyses recorded for each sample.</p><p>The classes are ordered and not balanced (class 1 has 59 samples, class 2 has 71 samples, and class 3 has 48 samples).</p><p>This dataset is also excellent for visualization techniques.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Datasets/Wine.jl#L5-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Datasets.make_blobs-Tuple{}" href="#NovaML.Datasets.make_blobs-Tuple{}"><code>NovaML.Datasets.make_blobs</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_blobs(;
    n_samples::Union{Int, Vector{Int}} = 100,
    n_features::Int = 2,
    centers::Union{Int, Matrix{Float64}} = nothing,
    cluster_std::Union{Float64, Vector{Float64}} = 1.0,
    center_box::Tuple{Float64, Float64} = (-10.0, 10.0),
    shuffle::Bool = true,
    random_state::Union{Int, Nothing} = nothing,
    return_centers::Bool = false
)</code></pre><p>Generate isotropic Gaussian blobs for clustering.</p><p><strong>Arguments</strong></p><ul><li><code>n_samples::Union{Int, Vector{Int}}</code>: The total number of points equally divided among clusters, or the number of samples per cluster.</li><li><code>n_features::Int</code>: The number of features for each sample.</li><li><code>centers::Union{Int, Matrix{Float64}}</code>: The number of centers to generate, or a matrix of center locations.</li><li><code>cluster_std::Union{Float64, Vector{Float64}}</code>: The standard deviation of the clusters.</li><li><code>center_box::Tuple{Float64, Float64}</code>: The bounding box for each cluster center when centers are generated at random.</li><li><code>shuffle::Bool</code>: Shuffle the samples.</li><li><code>random_state::Union{Int, Nothing}</code>: Determines random number generation for dataset creation.</li><li><code>return_centers::Bool</code>: If true, returns the centers in addition to X and y.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>return_centers</code> is false:<ul><li><code>X::Matrix{Float64}</code>: Generated samples.</li><li><code>y::Vector{Int}</code>: The integer labels for cluster membership of each sample.</li></ul></li><li>If <code>return_centers</code> is true:<ul><li><code>X::Matrix{Float64}</code>: Generated samples.</li><li><code>y::Vector{Int}</code>: The integer labels for cluster membership of each sample.</li><li><code>centers::Matrix{Float64}</code>: The centers used to generate the data.</li></ul></li></ul><p><strong>Description</strong></p><p>This function generates samples from isotropic Gaussian blobs for clustering. It can be used for testing clustering algorithms or as a simple dataset for demonstration purposes.</p><p><strong>Example</strong></p><p>```julia</p><p><strong>Generate a simple dataset with 3 clusters</strong></p><p>X, y = make<em>blobs(n</em>samples=300, centers=3, n<em>features=2, random</em>state=42)</p><p><strong>Generate a dataset with specified centers and return the centers</strong></p><p>centers = [0 0; 1 1; 2 2] X, y, centers = make<em>blobs(n</em>samples=300, centers=centers, cluster<em>std=0.5, return</em>centers=true)</p><p><strong>Notes</strong></p><p>If centers is an int, it is interpreted as the number of centers to generate, and they are generated randomly within center_box.</p><ul><li>If centers is a 2-d array, it is interpreted as the actual centers to use, and n_features is ignored in this case.</li><li>If n_samples is an int, it is interpreted as the total number of samples, which are then evenly divided among clusters.</li><li>If n_samples is an array, it is interpreted as the number of samples per cluster.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Datasets/MakeBlobs.jl#L4-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Datasets.make_moons-Tuple{}" href="#NovaML.Datasets.make_moons-Tuple{}"><code>NovaML.Datasets.make_moons</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">make_moons(;
    n_samples::Union{Int, Tuple{Int, Int}}=100,
    shuffle::Bool=true,
    noise::Union{Float64, Nothing}=nothing,
    random_state::Union{Int, Nothing}=nothing
)</code></pre><p>Generate two interleaving half circles for binary classification.</p><p><strong>Arguments</strong></p><ul><li><code>n_samples::Union{Int, Tuple{Int, Int}}</code>: The total number of points generated or a tuple containing the number of points in each of the two moons.</li><li><code>shuffle::Bool</code>: Whether to shuffle the samples.</li><li><code>noise::Union{Float64, Nothing}</code>: Standard deviation of Gaussian noise added to the data.</li><li><code>random_state::Union{Int, Nothing}</code>: Determines random number generation for dataset creation.</li></ul><p><strong>Returns</strong></p><ul><li><code>X::Matrix{Float64}</code>: The generated samples, of shape (n_samples, 2).</li><li><code>y::Vector{Int}</code>: The integer labels (0 or 1) for class membership of each sample.</li></ul><p><strong>Description</strong></p><p>This function generates a binary classification dataset in the shape of two interleaving half moons. It can be used for testing classification algorithms or as a simple dataset for demonstration purposes.</p><p><strong>Example</strong></p><p>```julia</p><p><strong>Generate a simple moon dataset</strong></p><p>X, y = make<em>moons(n</em>samples=100, noise=0.1, random_state=42)</p><p><strong>Generate a moon dataset with different number of samples in each moon</strong></p><p>X, y = make<em>moons(n</em>samples=(60, 40), noise=0.1, shuffle=false)</p><p><strong>Notes</strong></p><ul><li>If n_samples is an integer, it generates approximately equal numbers of samples in each moon.</li><li>If the number is odd, the extra sample is added to the first moon.</li><li>If n_samples is a tuple of two integers, it specifies the number of samples for each moon respectively.</li><li>The two moons are generated on a 2D plane. The first moon is a half circle of radius 1 centered at (0, 0),</li></ul><p>while the second moon is a half circle of radius 1 centered at (1, 0.5).</p><ul><li>If noise is specified, Gaussian noise with standard deviation noise is added to the data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Datasets/MakeMoons.jl#L3-L42">source</a></section></article><h2 id="Clustering"><a class="docs-heading-anchor" href="#Clustering">Clustering</a><a id="Clustering-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.AgglomerativeClustering" href="#NovaML.Cluster.AgglomerativeClustering"><code>NovaML.Cluster.AgglomerativeClustering</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AgglomerativeClustering</code></pre><p>A struct representing Agglomerative Clustering, a hierarchical clustering algorithm.</p><p><strong>Fields</strong></p><ul><li><code>n_clusters::Union{Int, Nothing}</code>: The number of clusters to find. If <code>nothing</code>, it must be used with <code>distance_threshold</code>.</li><li><code>metric::Union{String, Function}</code>: The metric to use for distance computation. Can be &quot;euclidean&quot;, &quot;manhattan&quot;, or a custom function.</li><li><code>memory::Union{String, Nothing}</code>: Used to cache the distance matrix between iterations.</li><li><code>connectivity::Union{AbstractMatrix, Function, Nothing}</code>: Connectivity matrix or callable to be used.</li><li><code>compute_full_tree::Union{Bool, String}</code>: Whether to compute the full tree or stop early.</li><li><code>linkage::String</code>: The linkage criterion to use. Can be &quot;ward&quot;, &quot;complete&quot;, &quot;average&quot;, or &quot;single&quot;.</li><li><code>distance_threshold::Union{Float64, Nothing}</code>: The threshold to stop clustering.</li><li><code>compute_distances::Bool</code>: Whether to compute distances.</li></ul><p><strong>Fitted Attributes</strong></p><ul><li><code>labels_::Vector{Int}</code>: Cluster labels for each point.</li><li><code>n_leaves_::Int</code>: Number of leaves in the hierarchical tree.</li><li><code>n_connected_components_::Int</code>: Number of connected components in the graph.</li><li><code>children_::Matrix{Int}</code>: The children of each non-leaf node.</li><li><code>distances_::Vector{Float64}</code>: Distances between nodes in the tree.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">AgglomerativeClustering(;
    n_clusters::Union{Int, Nothing}=2,
    metric::Union{String, Function}=&quot;euclidean&quot;,
    memory::Union{String, Nothing}=nothing,
    connectivity::Union{AbstractMatrix, Function, Nothing}=nothing,
    compute_full_tree::Union{Bool, String}=&quot;auto&quot;,
    linkage::String=&quot;ward&quot;,
    distance_threshold::Union{Float64, Nothing}=nothing,
    compute_distances::Bool=false
)</code></pre><p>Constructs an AgglomerativeClustering object with the specified parameters.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create an AgglomerativeClustering object with 3 clusters
clustering = AgglomerativeClustering(n_clusters=3)

# Create an AgglomerativeClustering object with a distance threshold
clustering = AgglomerativeClustering(distance_threshold=1.5, linkage=&quot;single&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/AgglomerativeClustering.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.AgglomerativeClustering-Tuple{AbstractMatrix{T} where T, Symbol}" href="#NovaML.Cluster.AgglomerativeClustering-Tuple{AbstractMatrix{T} where T, Symbol}"><code>NovaML.Cluster.AgglomerativeClustering</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>(clustering::AgglomerativeClustering)(X::AbstractMatrix, type::Symbol) Fit the clustering model and return the cluster labels.</p><p><strong>Arguments</strong></p><p>X::AbstractMatrix: The input data matrix. type::Symbol: Must be :fit_predict to fit the model and return labels.</p><p><strong>Returns</strong></p><p>labels::Vector{Int}: The cluster labels for each input sample.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">X = rand(100, 5)
clustering = AgglomerativeClustering(n_clusters=3)
labels = clustering(X, :fit_predict)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/AgglomerativeClustering.jl#L217-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.AgglomerativeClustering-Tuple{AbstractMatrix{T} where T}" href="#NovaML.Cluster.AgglomerativeClustering-Tuple{AbstractMatrix{T} where T}"><code>NovaML.Cluster.AgglomerativeClustering</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(clustering::AgglomerativeClustering)(X::AbstractMatrix; y=nothing)</code></pre><p>Perform agglomerative clustering on the input data.</p><p><strong>Arguments</strong></p><p>X::AbstractMatrix: The input data matrix where each row is a sample and each column is a feature. y=nothing: Ignored. Present for API consistency.</p><p><strong>Returns</strong></p><p>clustering::AgglomerativeClustering: The fitted clustering object.</p><p>#Examples</p><pre><code class="language-julia hljs">X = rand(100, 5)  # 100 samples, 5 features
clustering = AgglomerativeClustering(n_clusters=3)
fitted_clustering = clustering(X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/AgglomerativeClustering.jl#L87-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.DBSCAN" href="#NovaML.Cluster.DBSCAN"><code>NovaML.Cluster.DBSCAN</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DBSCAN</code></pre><p>A struct representing the DBSCAN (Density-Based Spatial Clustering of Applications with Noise) clustering algorithm.</p><p><strong>Fields</strong></p><ul><li><code>eps::Float64</code>: The maximum distance between two samples for one to be considered as in the neighborhood of the other.</li><li><code>min_samples::Int</code>: The number of samples in a neighborhood for a point to be considered as a core point.</li><li><code>metric::Union{String, Metric}</code>: The metric to use when calculating distance between instances.</li><li><code>metric_params::Union{Nothing, Dict}</code>: Additional keyword arguments for the metric function.</li><li><code>algorithm::Symbol</code>: The algorithm to be used by the NearestNeighbors module.</li><li><code>leaf_size::Int</code>: Leaf size passed to BallTree or KDTree.</li><li><code>p::Union{Nothing, Float64}</code>: The power of the Minkowski metric to be used to calculate distance between points.</li><li><code>n_jobs::Union{Nothing, Int}</code>: The number of parallel jobs to run.</li></ul><p><strong>Fitted Attributes</strong></p><ul><li><code>core_sample_indices_::Vector{Int}</code>: Indices of core samples.</li><li><code>components_::Matrix{Float64}</code>: Copy of each core sample found by training.</li><li><code>labels_::Vector{Int}</code>: Cluster labels for each point in the dataset given to fit().</li><li><code>n_features_in_::Int</code>: Number of features seen during fit.</li><li><code>feature_names_in_::Vector{String}</code>: Names of features seen during fit.</li><li><code>fitted::Bool</code>: Whether the model has been fitted.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DBSCAN(;
    eps::Float64 = 0.5,
    min_samples::Int = 5,
    metric::Union{String, Metric} = &quot;euclidean&quot;,
    metric_params::Union{Nothing, Dict} = nothing,
    algorithm::Symbol = :auto,
    leaf_size::Int = 30,
    p::Union{Nothing, Float64} = nothing,
    n_jobs::Union{Nothing, Int} = nothing
)</code></pre><p>Constructs a DBSCAN object with the specified parameters.</p><p><strong>Examples</strong></p><p>```julia</p><p><strong>Create a DBSCAN object with default parameters</strong></p><p>dbscan = DBSCAN()</p><p><strong>Create a DBSCAN object with custom parameters</strong></p><p>dbscan = DBSCAN(eps=0.7, min_samples=10, metric=&quot;manhattan&quot;)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/DBSCAN.jl#L6-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.DBSCAN" href="#NovaML.Cluster.DBSCAN"><code>NovaML.Cluster.DBSCAN</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(dbscan::DBSCAN)(X::AbstractMatrix, y=nothing; sample_weight=nothing)</code></pre><p>Perform DBSCAN clustering on the input data.</p><p><strong>Arguments</strong></p><p>X::AbstractMatrix: The input data matrix where each row is a sample and each column is a feature. y=nothing: Ignored. Present for API consistency. sample_weight=nothing: Weight of each sample, used in computing the number of neighbors within eps.</p><p><strong>Returns</strong></p><p>dbscan::DBSCAN: The fitted DBSCAN object.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">X = rand(100, 5)  # 100 samples, 5 features
dbscan = DBSCAN(eps=0.5, min_samples=5)
fitted_dbscan = dbscan(X)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/DBSCAN.jl#L84-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.KMeans" href="#NovaML.Cluster.KMeans"><code>NovaML.Cluster.KMeans</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KMeans &lt;: AbstractModel</code></pre><p>Represents the K-Means clustering algorithm.</p><p><strong>Fields</strong></p><ul><li><code>n_clusters::Int</code>: The number of clusters to form.</li><li><code>init::Union{String, Matrix{Float64}, Function}</code>: Method for initialization.</li><li><code>n_init::Union{Int, String}</code>: Number of time the k-means algorithm will be run with different centroid seeds.</li><li><code>max_iter::Int</code>: Maximum number of iterations of the k-means algorithm for a single run.</li><li><code>tol::Float64</code>: Relative tolerance with regards to inertia to declare convergence.</li><li><code>verbose::Int</code>: Verbosity mode.</li><li><code>random_state::Union{Int, Nothing}</code>: Determines random number generation for centroid initialization.</li><li><code>copy_x::Bool</code>: When pre-computing distances it is more numerically accurate to center the data first.</li><li><code>algorithm::String</code>: K-means algorithm to use.</li></ul><p><strong>Fitted Attributes</strong></p><ul><li><code>cluster_centers_::Union{Matrix{Float64}, Nothing}</code>: Coordinates of cluster centers.</li><li><code>labels_::Union{Vector{Int}, Nothing}</code>: Labels of each point.</li><li><code>inertia_::Union{Float64, Nothing}</code>: Sum of squared distances of samples to their closest cluster center.</li><li><code>n_iter_::Union{Int, Nothing}</code>: Number of iterations run.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L7-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.KMeans" href="#NovaML.Cluster.KMeans"><code>NovaML.Cluster.KMeans</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(kmeans::KMeans)(X::AbstractVecOrMat{Float64}, y=nothing; sample_weight=nothing)</code></pre><p>Compute k-means clustering.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractVecOrMat{Float64}</code>: Training instances to cluster.</li><li><code>y</code>: Ignored. Not used, present for API consistency by convention.</li><li><code>sample_weight</code>: The weights for each observation in X.</li></ul><p><strong>Returns</strong></p><ul><li>If the model is not fitted, returns the fitted model.</li><li>If the model is already fitted, returns the predicted labels for X.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, DBSCAN}" href="#Base.show-Tuple{IO, DBSCAN}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Base.show(io::IO, dbscan::DBSCAN) Custom show method for DBSCAN objects.</p><p><strong>Arguments</strong></p><p>io::IO: The I/O stream to which the representation is written. dbscan::DBSCAN: The DBSCAN object to be displayed.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">dbscan = DBSCAN(eps=0.7, min_samples=10)
println(dbscan)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/DBSCAN.jl#L234-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, KMeans}" href="#Base.show-Tuple{IO, KMeans}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, kmeans::KMeans)</code></pre><p>Custom show method for KMeans instances.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream.</li><li><code>kmeans::KMeans</code>: The KMeans instance to display.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L404-L412">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.assign_labels-Tuple{AbstractMatrix{Float64}, Matrix{Float64}}" href="#NovaML.Cluster.assign_labels-Tuple{AbstractMatrix{Float64}, Matrix{Float64}}"><code>NovaML.Cluster.assign_labels</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">assign_labels(X::AbstractMatrix{Float64}, centroids::Matrix{Float64})</code></pre><p>Assign labels to data points based on the nearest centroid.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix{Float64}</code>: The input data.</li><li><code>centroids::Matrix{Float64}</code>: The current centroids.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: The assigned labels for each data point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L209-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.compute_distances-Tuple{AbstractMatrix{T} where T, Union{Function, String}}" href="#NovaML.Cluster.compute_distances-Tuple{AbstractMatrix{T} where T, Union{Function, String}}"><code>NovaML.Cluster.compute_distances</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_distances(X::AbstractMatrix, metric::Union{String, Function})</code></pre><p>Compute the distance matrix for the input data using the specified metric.</p><p><strong>Arguments</strong></p><p>X::AbstractMatrix: The input data matrix. metric::Union{String, Function}: The distance metric to use. Can be &quot;euclidean&quot;, &quot;manhattan&quot;, or a custom function.</p><p><strong>Returns</strong></p><p>distances::Matrix: The computed distance matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">X = rand(10, 3)
distances = compute_distances(X, &quot;euclidean&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/AgglomerativeClustering.jl#L174-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.compute_inertia" href="#NovaML.Cluster.compute_inertia"><code>NovaML.Cluster.compute_inertia</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_inertia(X::Matrix{Float64}, centroids::Matrix{Float64}, labels::Vector{Int}, sample_weight=nothing)</code></pre><p>Compute the inertia, the sum of squared distances of samples to their closest cluster center.</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{Float64}</code>: The input data.</li><li><code>centroids::Matrix{Float64}</code>: The current centroids.</li><li><code>labels::Vector{Int}</code>: The current label assignments.</li><li><code>sample_weight</code>: The weights for each observation in X.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The computed inertia.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L259-L272">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.fit_predict" href="#NovaML.Cluster.fit_predict"><code>NovaML.Cluster.fit_predict</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_predict(kmeans::KMeans, X::Matrix{Float64}, y=nothing; sample_weight=nothing)</code></pre><p>Compute cluster centers and predict cluster index for each sample.</p><p><strong>Arguments</strong></p><ul><li><code>kmeans::KMeans</code>: The KMeans instance.</li><li><code>X::Matrix{Float64}</code>: New data to transform.</li><li><code>y</code>: Ignored.</li><li><code>sample_weight</code>: The weights for each observation in X.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: Index of the cluster each sample belongs to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L325-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.fit_transform" href="#NovaML.Cluster.fit_transform"><code>NovaML.Cluster.fit_transform</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_transform(kmeans::KMeans, X::Matrix{Float64}, y=nothing; sample_weight=nothing)</code></pre><p>Compute clustering and transform X to cluster-distance space.</p><p><strong>Arguments</strong></p><ul><li><code>kmeans::KMeans</code>: The KMeans instance.</li><li><code>X::Matrix{Float64}</code>: New data to transform.</li><li><code>y</code>: Ignored.</li><li><code>sample_weight</code>: The weights for each observation in X.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: X transformed in the new space.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L344-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.get_params-Tuple{DBSCAN}" href="#NovaML.Cluster.get_params-Tuple{DBSCAN}"><code>NovaML.Cluster.get_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get_params(dbscan::DBSCAN) Get parameters for this estimator.</p><p><strong>Returns</strong></p><p>params::Dict: Parameter names mapped to their values.</p><p><strong>Examples</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/DBSCAN.jl#L188-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.get_params-Tuple{KMeans}" href="#NovaML.Cluster.get_params-Tuple{KMeans}"><code>NovaML.Cluster.get_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_params(kmeans::KMeans; deep=true)</code></pre><p>Get parameters for this estimator.</p><p><strong>Arguments</strong></p><ul><li><code>kmeans::KMeans</code>: The KMeans instance.</li><li><code>deep::Bool</code>: If True, will return the parameters for this estimator and contained subobjects that are estimators.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict</code>: Parameter names mapped to their values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L280-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.initialize_centroids-Tuple{KMeans, Matrix{Float64}}" href="#NovaML.Cluster.initialize_centroids-Tuple{KMeans, Matrix{Float64}}"><code>NovaML.Cluster.initialize_centroids</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_centroids(kmeans::KMeans, X::Matrix{Float64})</code></pre><p>Initialize the centroids for K-Means clustering.</p><p><strong>Arguments</strong></p><ul><li><code>kmeans::KMeans</code>: The KMeans instance.</li><li><code>X::Matrix{Float64}</code>: The input data.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: The initial centroids.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L138-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.kmeans_plus_plus-Tuple{Matrix{Float64}, Int64}" href="#NovaML.Cluster.kmeans_plus_plus-Tuple{Matrix{Float64}, Int64}"><code>NovaML.Cluster.kmeans_plus_plus</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">kmeans_plus_plus(X::Matrix{Float64}, n_clusters::Int)</code></pre><p>Perform K-Means++ initialization.</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{Float64}</code>: The input data.</li><li><code>n_clusters::Int</code>: The number of clusters.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: The initial centroids chosen by K-Means++.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L173-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.score" href="#NovaML.Cluster.score"><code>NovaML.Cluster.score</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">score(kmeans::KMeans, X::Matrix{Float64}, y=nothing; sample_weight=nothing)</code></pre><p>Opposite of the value of X on the K-means objective.</p><p><strong>Arguments</strong></p><ul><li><code>kmeans::KMeans</code>: The KMeans instance.</li><li><code>X::Matrix{Float64}</code>: New data.</li><li><code>y</code>: Ignored.</li><li><code>sample_weight</code>: The weights for each observation in X.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: Opposite of the value of X on the K-means objective.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L382-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.set_params!-Tuple{DBSCAN}" href="#NovaML.Cluster.set_params!-Tuple{DBSCAN}"><code>NovaML.Cluster.set_params!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>set_params!(dbscan::DBSCAN; kwargs...) Set the parameters of this estimator.</p><p><strong>Arguments</strong></p><p>kwargs...: Estimator parameters.</p><p><strong>Returns</strong></p><p>dbscan::DBSCAN: The DBSCAN object.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">dbscan = DBSCAN()
set_params!(dbscan, eps=0.8, min_samples=15)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/DBSCAN.jl#L211-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.set_params!-Tuple{KMeans}" href="#NovaML.Cluster.set_params!-Tuple{KMeans}"><code>NovaML.Cluster.set_params!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_params!(kmeans::KMeans; params...)</code></pre><p>Set the parameters of this estimator.</p><p><strong>Arguments</strong></p><ul><li><code>kmeans::KMeans</code>: The KMeans instance.</li><li><code>params...</code>: Estimator parameters.</li></ul><p><strong>Returns</strong></p><ul><li><code>KMeans</code>: The estimator instance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L306-L317">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.transform-Tuple{KMeans, Matrix{Float64}}" href="#NovaML.Cluster.transform-Tuple{KMeans, Matrix{Float64}}"><code>NovaML.Cluster.transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform(kmeans::KMeans, X::Matrix{Float64})</code></pre><p>Transform X to a cluster-distance space.</p><p><strong>Arguments</strong></p><ul><li><code>kmeans::KMeans</code>: The KMeans instance.</li><li><code>X::Matrix{Float64}</code>: New data to transform.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: X transformed in the new space.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L363-L374">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Cluster.update_centroids" href="#NovaML.Cluster.update_centroids"><code>NovaML.Cluster.update_centroids</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_centroids(X::Matrix{Float64}, labels::Vector{Int}, n_clusters::Int, sample_weight=nothing)</code></pre><p>Update the centroids based on the current label assignments.</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{Float64}</code>: The input data.</li><li><code>labels::Vector{Int}</code>: The current label assignments.</li><li><code>n_clusters::Int</code>: The number of clusters.</li><li><code>sample_weight</code>: The weights for each observation in X.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: The updated centroids.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Cluster/KMeans.jl#L225-L238">source</a></section></article><h2 id="Decomposition"><a class="docs-heading-anchor" href="#Decomposition">Decomposition</a><a id="Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Decomposition" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Decomposition.LatentDirichletAllocation" href="#NovaML.Decomposition.LatentDirichletAllocation"><code>NovaML.Decomposition.LatentDirichletAllocation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LatentDirichletAllocation</code></pre><p>Latent Dirichlet Allocation (LDA) with online variational Bayes algorithm.</p><p>LDA is a generative probabilistic model for collections of discrete dataset such as text corpora. It is also a topic model that is used for discovering abstract topics from a collection of documents.</p><p><strong>Fields</strong></p><ul><li><code>n_components::Int</code>: Number of topics.</li><li><code>doc_topic_prior::Union{Float64, Nothing}</code>: Prior of document topic distribution.</li><li><code>topic_word_prior::Union{Float64, Nothing}</code>: Prior of topic word distribution.</li><li><code>learning_method::Symbol</code>: Method used to update the model: :batch for batch learning, :online for online learning.</li><li><code>learning_decay::Float64</code>: It is a parameter that control the rate at which the learning rate decreases.</li><li><code>learning_offset::Float64</code>: A (positive) parameter that downweights early iterations in online learning.</li><li><code>max_iter::Int</code>: The maximum number of iterations.</li><li><code>batch_size::Int</code>: Number of documents to use in each EM iteration in online learning method.</li><li><code>evaluate_every::Int</code>: How often to evaluate perplexity.</li><li><code>total_samples::Float64</code>: Total number of documents.</li><li><code>perp_tol::Float64</code>: Perplexity tolerance in batch learning.</li><li><code>mean_change_tol::Float64</code>: Stopping tolerance for updating document topic distribution in E-step.</li><li><code>max_doc_update_iter::Int</code>: Max number of iterations for updating document topic distribution in E-step.</li><li><code>n_jobs::Union{Int, Nothing}</code>: The number of jobs to use in the E-step.</li><li><code>verbose::Int</code>: Verbosity level.</li><li><code>random_state::Union{Int, Nothing}</code>: Seed for random number generation.</li></ul><p><strong>Learned attributes</strong></p><ul><li><code>components_::Union{Matrix{Float64}, Nothing}</code>: Topic word distribution. shape = (n<em>components, n</em>features)</li><li><code>exp_dirichlet_component_::Union{Matrix{Float64}, Nothing}</code>: Exponential value of expectation of log topic word distribution. shape = (n<em>components, n</em>features)</li><li><code>n_batch_iter_::Int</code>: Number of iterations of the EM step.</li><li><code>n_iter_::Int</code>: Number of passes over the dataset.</li><li><code>bound_::Float64</code>: Final perplexity score on training set.</li><li><code>n_features_in_::Int</code>: Number of features seen during fit.</li><li><code>feature_names_in_::Union{Vector{String}, Nothing}</code>: Names of features seen during fit.</li></ul><p><strong>Example</strong></p><p>```julia using NovaML</p><p><strong>Create an LDA model</strong></p><p>lda = LatentDirichletAllocation(n<em>components=10, random</em>state=42)</p><p><strong>Fit the model to data</strong></p><p>doc<em>topic</em>distr = lda(X)</p><p><strong>Transform new data</strong></p><p>new<em>doc</em>topic<em>distr = lda(new</em>X)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/LatentDirichletAllocation.jl#L7-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Decomposition.PCA" href="#NovaML.Decomposition.PCA"><code>NovaML.Decomposition.PCA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PCA</code></pre><p>Principal Component Analysis (PCA).</p><p>Linear dimensionality reduction using Singular Value Decomposition of the data to project it to a lower dimensional space.</p><p><strong>Fields</strong></p><ul><li><code>n_components::Union{Int, Float64, String, Nothing}</code>: Number of components to keep.</li><li><code>whiten::Bool</code>: When True, the <code>components_</code> vectors are multiplied by the square root of n_samples and then divided by the singular values to ensure uncorrelated outputs with unit component-wise variances.</li><li><code>fitted::Bool</code>: Whether the PCA model has been fitted to data.</li></ul><p><strong>Fitted Attributes</strong></p><ul><li><code>components_::Union{Matrix{Float64}, Nothing}</code>: Principal axes in feature space, representing the directions of maximum variance in the data.</li><li><code>explained_variance_::Union{Vector{Float64}, Nothing}</code>: The amount of variance explained by each of the selected components.</li><li><code>explained_variance_ratio_::Union{Vector{Float64}, Nothing}</code>: Percentage of variance explained by each of the selected components.</li><li><code>singular_values_::Union{Vector{Float64}, Nothing}</code>: The singular values corresponding to each of the selected components.</li><li><code>mean_::Union{Vector{Float64}, Nothing}</code>: Per-feature empirical mean, estimated from the training set.</li><li><code>n_samples_::Union{Int, Nothing}</code>: Number of samples in the training data.</li><li><code>n_features_::Union{Int, Nothing}</code>: Number of features in the training data.</li><li><code>n_components_::Union{Int, Nothing}</code>: The estimated number of components.</li><li><code>noise_variance_::Union{Float64, Nothing}</code>: The estimated noise covariance following the Probabilistic PCA model.</li></ul><p><strong>Methods</strong></p><ul><li><code>(::PCA)(X::AbstractMatrix)</code>: Fit the model with X and apply dimensionality reduction on X.</li><li><code>(::PCA)(X::AbstractMatrix, mode::Symbol)</code>: Transform data back to its original space when mode is :inverse_transform.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">pca = PCA(n_components=2)
X_transformed = pca(X)
X_inverse = pca(X_transformed, :inverse_transform)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/PCA.jl#L4-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, LatentDirichletAllocation}" href="#Base.show-Tuple{IO, LatentDirichletAllocation}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, lda::LatentDirichletAllocation)</code></pre><p>Custom show method for LatentDirichletAllocation.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream</li><li><code>lda::LatentDirichletAllocation</code>: The LDA model to display</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/LatentDirichletAllocation.jl#L377-L384">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, PCA}" href="#Base.show-Tuple{IO, PCA}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, pca::PCA)</code></pre><p>Custom show method for PCA.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream.</li><li><code>pca::PCA</code>: The PCA model to display.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/PCA.jl#L125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Decomposition._e_step-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}}} where T&lt;:Real" href="#NovaML.Decomposition._e_step-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}}} where T&lt;:Real"><code>NovaML.Decomposition._e_step</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_e_step(lda::LatentDirichletAllocation, X::AbstractMatrix{T}) where T &lt;: Real</code></pre><p>E-step in EM update.</p><p><strong>Arguments</strong></p><ul><li><code>lda::LatentDirichletAllocation</code>: The LDA model.</li><li><code>X::AbstractMatrix{T}</code>: Document-term matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Document-topic distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/LatentDirichletAllocation.jl#L239-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Decomposition._fit_batch-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}}} where T&lt;:Real" href="#NovaML.Decomposition._fit_batch-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}}} where T&lt;:Real"><code>NovaML.Decomposition._fit_batch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_fit_batch(lda::LatentDirichletAllocation, X::AbstractMatrix{T}) where T &lt;: Real</code></pre><p>Fit the model to X using batch variational Bayes method.</p><p><strong>Arguments</strong></p><ul><li><code>lda::LatentDirichletAllocation</code>: The LDA model.</li><li><code>X::AbstractMatrix{T}</code>: Document-term matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Document-topic distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/LatentDirichletAllocation.jl#L159-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Decomposition._fit_online-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}}} where T&lt;:Real" href="#NovaML.Decomposition._fit_online-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}}} where T&lt;:Real"><code>NovaML.Decomposition._fit_online</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_fit_online(lda::LatentDirichletAllocation, X::AbstractMatrix{T}) where T &lt;: Real</code></pre><p>Fit the model to X using online variational Bayes method.</p><p><strong>Arguments</strong></p><ul><li><code>lda::LatentDirichletAllocation</code>: The LDA model.</li><li><code>X::AbstractMatrix{T}</code>: Document-term matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Document-topic distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/LatentDirichletAllocation.jl#L196-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Decomposition._m_step-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}, Matrix{Float64}}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}, Matrix{Float64}, Float64}} where T&lt;:Real" href="#NovaML.Decomposition._m_step-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}, Matrix{Float64}}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}, Matrix{Float64}, Float64}} where T&lt;:Real"><code>NovaML.Decomposition._m_step</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_m_step(lda::LatentDirichletAllocation, X::AbstractMatrix{T}, doc_topic_distr::Matrix{Float64}, scale::Float64=1.0) where T &lt;: Real</code></pre><p>M-step in EM update.</p><p><strong>Arguments</strong></p><ul><li><code>lda::LatentDirichletAllocation</code>: The LDA model.</li><li><code>X::AbstractMatrix{T}</code>: Document-term matrix.</li><li><code>doc_topic_distr::Matrix{Float64}</code>: Document-topic distribution.</li><li><code>scale</code>::Float64: Scaling factor for online update.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/LatentDirichletAllocation.jl#L286-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Decomposition._perplexity-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}, Matrix{Float64}}} where T&lt;:Real" href="#NovaML.Decomposition._perplexity-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}, Matrix{Float64}}} where T&lt;:Real"><code>NovaML.Decomposition._perplexity</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_perplexity(lda::LatentDirichletAllocation, X::AbstractMatrix{T}, doc_topic_distr::Matrix{Float64}) where T &lt;: Real</code></pre><p>Calculate approximate perplexity for data X.</p><p><strong>Arguments</strong></p><ul><li><code>lda::LatentDirichletAllocation</code>: The LDA model.</li><li><code>X::AbstractMatrix{T}</code>: Document-term matrix.</li><li><code>doc_topic_distr::Matrix{Float64}</code>: Document-topic distribution.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The calculated bound.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/LatentDirichletAllocation.jl#L327-L338">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Decomposition._transform-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}}} where T&lt;:Real" href="#NovaML.Decomposition._transform-Union{Tuple{T}, Tuple{LatentDirichletAllocation, AbstractMatrix{T}}} where T&lt;:Real"><code>NovaML.Decomposition._transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_transform(lda::LatentDirichletAllocation, X::AbstractMatrix{T}) where T &lt;: Real</code></pre><p>Transform X to document-topic distribution.</p><p><strong>Arguments</strong></p><ul><li><code>lda::LatentDirichletAllocation</code>: The LDA model.</li><li><code>X::AbstractMatrix{T}</code>: Document-term matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: Document-topic distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Decomposition/LatentDirichletAllocation.jl#L312-L322">source</a></section></article><h2 id="Ensemble-Methods"><a class="docs-heading-anchor" href="#Ensemble-Methods">Ensemble Methods</a><a id="Ensemble-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.AdaBoostClassifier" href="#NovaML.Ensemble.AdaBoostClassifier"><code>NovaML.Ensemble.AdaBoostClassifier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdaBoostClassifier &lt;: AbstractModel</code></pre><p>An AdaBoost classifier.</p><p>An AdaBoost classifier is a meta-estimator that begins by fitting a classifier on the original dataset and then fits additional copies of the classifier on the same dataset but where the weights of incorrectly classified instances are adjusted such that subsequent classifiers focus more on difficult cases.</p><p><strong>Fields</strong></p><ul><li><code>base_estimator::Any</code>: The base estimator from which the boosted ensemble is built.</li><li><code>n_estimators::Int</code>: The maximum number of estimators at which boosting is terminated.</li><li><code>learning_rate::Float64</code>: Weight applied to each classifier at each boosting iteration.</li><li><code>algorithm::Symbol</code>: The SAMME algorithm to use when fitting the model.</li><li><code>random_state::Union{Int, Nothing}</code>: Controls the random seed given at each <code>base_estimator</code> at each boosting iteration.</li></ul><p><strong>Fitted Attributes</strong></p><ul><li><code>estimators_::Vector{Any}</code>: The collection of fitted sub-estimators.</li><li><code>estimator_weights_::Vector{Float64}</code>: Weights for each estimator in the boosted ensemble.</li><li><code>estimator_errors_::Vector{Float64}</code>: Classification error for each estimator in the boosted ensemble.</li><li><code>classes_::Vector{Any}</code>: The classes labels.</li><li><code>n_classes_::Int</code>: The number of classes.</li><li><code>feature_importances_::Union{Vector{Float64}, Nothing}</code>: The feature importances if supported by the <code>base_estimator</code>.</li><li><code>fitted::Bool</code>: Whether the model has been fitted.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = AdaBoostClassifier(n_estimators=100, learning_rate=1.0)
model(X, y)  # Fit the model
predictions = model(X_test)  # Make predictions
probabilities = model(X_test, type=:probs)  # Get probability estimates</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L7-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.AdaBoostClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}" href="#NovaML.Ensemble.AdaBoostClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}"><code>NovaML.Ensemble.AdaBoostClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>(model::AdaBoostClassifier)(X::AbstractMatrix, y::AbstractVector) Fit the AdaBoost model.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>y::AbstractVector</code>: The target values (class labels).</li></ul><p><strong>Returns</strong></p><ul><li><code>AdaBoostClassifier</code>: The fitted model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.AdaBoostClassifier-Tuple{AbstractMatrix{T} where T}" href="#NovaML.Ensemble.AdaBoostClassifier-Tuple{AbstractMatrix{T} where T}"><code>NovaML.Ensemble.AdaBoostClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(model::AdaBoostClassifier)(X::AbstractMatrix; type=nothing)</code></pre><p>Predict using the AdaBoost model.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>type</code>: If set to :probs, return probability estimates for each class.</li></ul><p><strong>Returns</strong></p><ul><li>If type is :probs, returns probabilities of each class.</li><li>Otherwise, returns predicted class labels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L160-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.BaggingClassifier" href="#NovaML.Ensemble.BaggingClassifier"><code>NovaML.Ensemble.BaggingClassifier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BaggingClassifier &lt;: AbstractModel</code></pre><p>A Bagging classifier.</p><p>A Bagging classifier is an ensemble meta-estimator that fits base classifiers each on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator (e.g., a decision tree), by introducing randomization into its construction procedure and then making an ensemble out of it.</p><p><strong>Fields</strong></p><ul><li><code>base_estimator::AbstractModel</code>: The base estimator to fit on random subsets of the dataset.</li><li><code>n_estimators::Int</code>: The number of base estimators in the ensemble.</li><li><code>max_samples::Union{Int, Float64}</code>: The number of samples to draw from X to train each base estimator.</li><li><code>max_features::Union{Int, Float64}</code>: The number of features to draw from X to train each base estimator.</li><li><code>bootstrap::Bool</code>: Whether samples are drawn with replacement.</li><li><code>bootstrap_features::Bool</code>: Whether features are drawn with replacement.</li><li><code>oob_score::Bool</code>: Whether to use out-of-bag samples to estimate the generalization error.</li><li><code>warm_start::Bool</code>: When set to True, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new ensemble.</li><li><code>random_state::Union{Int, Nothing}</code>: Controls the random resampling of the original dataset.</li><li><code>verbose::Int</code>: Controls the verbosity when fitting and predicting.</li></ul><p><strong>Fitted Attributes</strong></p><ul><li><code>estimators_::Vector{AbstractModel}</code>: The collection of fitted base estimators.</li><li><code>estimators_features_::Vector{Vector{Int}}</code>: The subset of drawn features for each base estimator.</li><li><code>classes_::Vector</code>: The classes labels.</li><li><code>n_classes_::Int</code>: The number of classes.</li><li><code>oob_score_::Union{Float64, Nothing}</code>: Score of the training dataset obtained using an out-of-bag estimate.</li><li><code>oob_decision_function_::Union{Matrix{Float64}, Nothing}</code>: Decision function computed with out-of-bag estimate on the training set.</li><li><code>fitted::Bool</code>: Whether the model has been fitted.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = BaggingClassifier(base_estimator=DecisionTreeClassifier(), n_estimators=10)
model(X, y)  # Fit the model
predictions = model(X_test)  # Make predictions
probabilities = model(X_test, type=:probs)  # Get probability estimates</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/BaggingClassifier.jl#L5-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.BaggingClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}" href="#NovaML.Ensemble.BaggingClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}"><code>NovaML.Ensemble.BaggingClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(bc::BaggingClassifier)(X::AbstractMatrix, y::AbstractVector)</code></pre><p>Fit the Bagging classifier.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>y::AbstractVector</code>: The target values (class labels).</li></ul><p><strong>Returns</strong></p><ul><li><code>BaggingClassifier</code>: The fitted model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/BaggingClassifier.jl#L83-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.BaggingClassifier-Tuple{AbstractMatrix{T} where T}" href="#NovaML.Ensemble.BaggingClassifier-Tuple{AbstractMatrix{T} where T}"><code>NovaML.Ensemble.BaggingClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(bc::BaggingClassifier)(X::AbstractMatrix; type=nothing)</code></pre><p>Predict class for X.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>type</code>: If set to :probs, return probability estimates for each class.</li></ul><p><strong>Returns</strong></p><ul><li>If type is :probs, returns probabilities of each class.</li><li>Otherwise, returns predicted class labels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/BaggingClassifier.jl#L148-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.GradientBoostingClassifier" href="#NovaML.Ensemble.GradientBoostingClassifier"><code>NovaML.Ensemble.GradientBoostingClassifier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientBoostingClassifier &lt;: AbstractModel</code></pre><p>Gradient Boosting for classification.</p><p>GB builds an additive model in a forward stage-wise fashion; it allows for the optimization of arbitrary differentiable loss functions. In each stage a regression tree is fit on the negative gradient of the given loss function.</p><p><strong>Fields</strong></p><ul><li><code>loss::String</code>: The loss function to be optimized.</li><li><code>learning_rate::Float64</code>: Learning rate shrinks the contribution of each tree by <code>learning_rate</code>.</li><li><code>n_estimators::Int</code>: The number of boosting stages to perform.</li><li><code>subsample::Float64</code>: The fraction of samples to be used for fitting the individual base learners.</li><li><code>criterion::String</code>: The function to measure the quality of a split.</li><li><code>min_samples_split::Union{Int, Float64}</code>: The minimum number of samples required to split an internal node.</li><li><code>min_samples_leaf::Union{Int, Float64}</code>: The minimum number of samples required to be at a leaf node.</li><li><code>min_weight_fraction_leaf::Float64</code>: The minimum weighted fraction of the sum total of weights required to be at a leaf node.</li><li><code>max_depth::Union{Int, Nothing}</code>: Maximum depth of the individual regression estimators.</li><li><code>min_impurity_decrease::Float64</code>: A node will be split if this split induces a decrease of the impurity greater than or equal to this value.</li><li><code>init::Union{AbstractModel, String, Nothing}</code>: An estimator object that is used to compute the initial predictions.</li><li><code>random_state::Union{Int, Nothing}</code>: Controls the random seed given at each tree_estimator at each boosting iteration.</li><li><code>max_features::Union{Int, Float64, String, Nothing}</code>: The number of features to consider when looking for the best split.</li><li><code>verbose::Int</code>: Enable verbose output.</li><li><code>max_leaf_nodes::Union{Int, Nothing}</code>: Grow trees with <code>max_leaf_nodes</code> in best-first fashion.</li><li><code>warm_start::Bool</code>: When set to <code>true</code>, reuse the solution of the previous call to fit and add more estimators to the ensemble.</li><li><code>validation_fraction::Float64</code>: The proportion of training data to set aside as validation set for early stopping.</li><li><code>n_iter_no_change::Union{Int, Nothing}</code>: Used to decide if early stopping will be used to terminate training when validation score is not improving.</li><li><code>tol::Float64</code>: Tolerance for the early stopping.</li><li><code>ccp_alpha::Float64</code>: Complexity parameter used for Minimal Cost-Complexity Pruning.</li></ul><p><strong>Fitted Attributes</strong></p><ul><li><code>estimators_::Vector{Vector{DecisionTreeRegressor}}</code>: The collection of fitted sub-estimators.</li><li><code>classes_::Vector</code>: The classes labels.</li><li><code>n_classes_::Int</code>: The number of classes.</li><li><code>feature_importances_::Union{Vector{Float64}, Nothing}</code>: The feature importances.</li><li><code>oob_improvement_::Union{Vector{Float64}, Nothing}</code>: The improvement in loss on the out-of-bag samples relative to the previous iteration.</li><li><code>train_score_::Vector{Float64}</code>: The i-th score <code>train_score_[i]</code> is the loss of the model at iteration <code>i</code> on the in-bag sample.</li><li><code>n_estimators_::Int</code>: The number of estimators as selected by early stopping.</li><li><code>init_::Union{AbstractModel, Nothing}</code>: The estimator that provides the initial predictions.</li><li><code>fitted::Bool</code>: Whether the model has been fitted.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = GradientBoostingClassifier(n_estimators=100, learning_rate=1.0, max_depth=1)
model(X, y)  # Fit the model
predictions = model(X_test)  # Make predictions
probabilities = model(X_test, type=:probs)  # Get probability estimates</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L8-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.GradientBoostingClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}" href="#NovaML.Ensemble.GradientBoostingClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}"><code>NovaML.Ensemble.GradientBoostingClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(gbm::GradientBoostingClassifier)(X::AbstractMatrix, y::AbstractVector)</code></pre><p>Fit the gradient boosting model.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>y::AbstractVector</code>: The target values (class labels).</li></ul><p><strong>Returns</strong></p><ul><li><code>GradientBoostingClassifier</code>: The fitted model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L123-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.GradientBoostingClassifier-Tuple{AbstractMatrix{T} where T}" href="#NovaML.Ensemble.GradientBoostingClassifier-Tuple{AbstractMatrix{T} where T}"><code>NovaML.Ensemble.GradientBoostingClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(gbm::GradientBoostingClassifier)(X::AbstractMatrix; type=nothing)</code></pre><p>Predict class for X.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>type</code>: If set to <code>:probs</code>, return probability estimates for each class.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>type</code> is <code>:probs</code>, returns probabilities of each class.</li><li>Otherwise, returns predicted class labels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L213-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.InitialEstimator" href="#NovaML.Ensemble.InitialEstimator"><code>NovaML.Ensemble.InitialEstimator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InitialEstimator &lt;: AbstractModel</code></pre><p>An initial estimator that always predicts a constant probability.</p><p><strong>Fields</strong></p><ul><li><code>prob::Float64</code>: The constant probability to predict.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L313-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.InitialEstimator-Tuple{AbstractMatrix{T} where T}" href="#NovaML.Ensemble.InitialEstimator-Tuple{AbstractMatrix{T} where T}"><code>NovaML.Ensemble.InitialEstimator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(estimator::InitialEstimator)(X::AbstractMatrix)</code></pre><p>Predict using the initial estimator.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The predictions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L324-L333">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.RandomForestClassifier" href="#NovaML.Ensemble.RandomForestClassifier"><code>NovaML.Ensemble.RandomForestClassifier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RandomForestClassifier &lt;: AbstractModel</code></pre><p>A random forest classifier.</p><p>Random forests are an ensemble learning method for classification that operate by constructing a multitude of decision trees at training time and outputting the class that is the mode of the classes of the individual trees.</p><p><strong>Fields</strong></p><ul><li><code>n_estimators::Int</code>: The number of trees in the forest.</li><li><code>max_depth::Union{Int, Nothing}</code>: The maximum depth of the tree.</li><li><code>min_samples_split::Int</code>: The minimum number of samples required to split an internal node.</li><li><code>min_samples_leaf::Int</code>: The minimum number of samples required to be at a leaf node.</li><li><code>max_features::Union{Int, Float64, String, Nothing}</code>: The number of features to consider when looking for the best split.</li><li><code>bootstrap::Bool</code>: Whether bootstrap samples are used when building trees.</li><li><code>random_state::Union{Int, Nothing}</code>: Controls both the randomness of the bootstrapping of the samples used when building trees and the sampling of the features to consider when looking for the best split at each node.</li><li><code>trees::Vector{DecisionTreeClassifier}</code>: The collection of fitted sub-estimators.</li><li><code>n_classes::Int</code>: The number of classes.</li><li><code>classes::Vector</code>: The class labels.</li><li><code>fitted::Bool</code>: Whether the model has been fitted.</li><li><code>feature_importances_::Union{Vector{Float64}, Nothing}</code>: The feature importances.</li><li><code>n_features::Int</code>: The number of features when fitting the model.</li></ul><p><strong>Example</strong></p><p>```julia rf = RandomForestClassifier(n<em>estimators=100, max</em>depth=10) rf(X, y)  # Fit the model predictions = rf(X_test)  # Make predictions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestClassifier.jl#L7-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.RandomForestClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}" href="#NovaML.Ensemble.RandomForestClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}"><code>NovaML.Ensemble.RandomForestClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(forest::RandomForestClassifier)(X::AbstractMatrix, y::AbstractVector)</code></pre><p>Fit the random forest classifier.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>y::AbstractVector</code>: The target values (class labels).</li></ul><p><strong>Returns</strong></p><ul><li><code>RandomForestClassifier</code>: The fitted model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestClassifier.jl#L79-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.RandomForestClassifier-Tuple{AbstractMatrix{T} where T}" href="#NovaML.Ensemble.RandomForestClassifier-Tuple{AbstractMatrix{T} where T}"><code>NovaML.Ensemble.RandomForestClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(forest::RandomForestClassifier)(X::AbstractMatrix)</code></pre><p>Predict class for X.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: The predicted class labels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestClassifier.jl#L135-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.RandomForestRegressor" href="#NovaML.Ensemble.RandomForestRegressor"><code>NovaML.Ensemble.RandomForestRegressor</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RandomForestRegressor &lt;: AbstractModel</code></pre><p>A random forest regressor.</p><p>Random forests are an ensemble learning method for regression that operate by constructing a multitude of decision trees at training time and outputting the mean prediction of the individual trees.</p><p><strong>Fields</strong></p><ul><li><code>n_estimators::Int</code>: The number of trees in the forest.</li><li><code>criterion::String</code>: The function to measure the quality of a split.</li><li><code>max_depth::Union{Int, Nothing}</code>: The maximum depth of the tree.</li><li><code>min_samples_split::Int</code>: The minimum number of samples required to split an internal node.</li><li><code>min_samples_leaf::Int</code>: The minimum number of samples required to be at a leaf node.</li><li><code>min_weight_fraction_leaf::Float64</code>: The minimum weighted fraction of the sum total of weights required to be at a leaf node.</li><li><code>max_features::Union{Int, Float64, String, Nothing}</code>: The number of features to consider when looking for the best split.</li><li><code>max_leaf_nodes::Union{Int, Nothing}</code>: Grow trees with max<em>leaf</em>nodes in best-first fashion.</li><li><code>min_impurity_decrease::Float64</code>: A node will be split if this split induces a decrease of the impurity greater than or equal to this value.</li><li><code>bootstrap::Bool</code>: Whether bootstrap samples are used when building trees.</li><li><code>oob_score::Bool</code>: Whether to use out-of-bag samples to estimate the generalization score.</li><li><code>n_jobs::Union{Int, Nothing}</code>: The number of jobs to run in parallel.</li><li><code>random_state::Union{Int, Nothing}</code>: Controls both the randomness of the bootstrapping of the samples used when building trees and the sampling of the features to consider when looking for the best split at each node.</li><li><code>verbose::Int</code>: Controls the verbosity when fitting and predicting.</li><li><code>warm_start::Bool</code>: When set to true, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.</li><li><code>ccp_alpha::Float64</code>: Complexity parameter used for Minimal Cost-Complexity Pruning.</li><li><code>max_samples::Union{Int, Float64, Nothing}</code>: If bootstrap is True, the number of samples to draw from X to train each base estimator.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">rf = RandomForestRegressor(n_estimators=100, max_depth=10)
rf(X, y)  # Fit the model
predictions = rf(X_test)  # Make predictions</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestRegressor.jl#L8-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.RandomForestRegressor-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}" href="#NovaML.Ensemble.RandomForestRegressor-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}"><code>NovaML.Ensemble.RandomForestRegressor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(forest::RandomForestRegressor)(X::AbstractMatrix, y::AbstractVector)</code></pre><p>Fit the random forest regressor.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>y::AbstractVector</code>: The target values.</li></ul><p><strong>Returns</strong></p><ul><li><code>RandomForestRegressor</code>: The fitted model.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestRegressor.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.RandomForestRegressor-Tuple{AbstractMatrix{T} where T}" href="#NovaML.Ensemble.RandomForestRegressor-Tuple{AbstractMatrix{T} where T}"><code>NovaML.Ensemble.RandomForestRegressor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(forest::RandomForestRegressor)(X::AbstractMatrix)</code></pre><p>Predict regression target for X.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The predicted values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestRegressor.jl#L168-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.VotingClassifier" href="#NovaML.Ensemble.VotingClassifier"><code>NovaML.Ensemble.VotingClassifier</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VotingClassifier &lt;: AbstractModel</code></pre><p>A Voting Classifier for combining multiple machine learning classifiers.</p><p>This classifier combines a number of estimators to create a single classifier that makes predictions based on either hard voting (majority vote) or soft voting (weighted average of predicted probabilities).</p><p><strong>Fields</strong></p><ul><li><code>estimators::Vector{Tuple{String, Any}}</code>: List of (name, estimator) tuples.</li><li><code>voting::Symbol</code>: The voting strategy, either :hard for majority voting or :soft for probability voting.</li><li><code>weights::Union{Vector{Float64}, Nothing}</code>: Sequence of weights for each estimator in soft voting.</li><li><code>flatten_transform::Bool</code>: Affects the shape of transform output.</li><li><code>verbose::Bool</code>: If true, prints progress messages during fitting.</li></ul><p><strong>Fitted Attributes</strong></p><ul><li><code>estimators_::Vector{Any}</code>: The fitted estimators.</li><li><code>classes_::Vector{Any}</code>: The class labels.</li><li><code>fitted::Bool</code>: Whether the classifier is fitted.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">estimators = [(&quot;lr&quot;, LogisticRegression()), (&quot;rf&quot;, RandomForestClassifier())]
vc = VotingClassifier(estimators=estimators, voting=:soft)
vc(X, y)  # Fit the classifier
predictions = vc(X_test)  # Make predictions</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/VotingClassifier.jl#L7-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.VotingClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}" href="#NovaML.Ensemble.VotingClassifier-Tuple{AbstractMatrix{T} where T, AbstractVector{T} where T}"><code>NovaML.Ensemble.VotingClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(vc::VotingClassifier)(X::AbstractMatrix, y::AbstractVector)</code></pre><p>Fit the voting classifier.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>y::AbstractVector</code>: The target values (class labels).</li></ul><p><strong>Returns</strong></p><ul><li><code>VotingClassifier</code>: The fitted classifier.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/VotingClassifier.jl#L64-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.VotingClassifier-Tuple{AbstractMatrix{T} where T}" href="#NovaML.Ensemble.VotingClassifier-Tuple{AbstractMatrix{T} where T}"><code>NovaML.Ensemble.VotingClassifier</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(vc::VotingClassifier)(X::AbstractMatrix; type=nothing)</code></pre><p>Predict class labels for X.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>type</code>: If set to :probs, return probability estimates for each class.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>type</code> is <code>:probs</code>, returns probabilities of each class.</li><li>Otherwise, returns predicted class labels.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/VotingClassifier.jl#L92-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.ZeroEstimator" href="#NovaML.Ensemble.ZeroEstimator"><code>NovaML.Ensemble.ZeroEstimator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ZeroEstimator &lt;: AbstractModel</code></pre><p>An estimator that always predicts zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L353-L356">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.ZeroEstimator-Tuple{AbstractMatrix{T} where T}" href="#NovaML.Ensemble.ZeroEstimator-Tuple{AbstractMatrix{T} where T}"><code>NovaML.Ensemble.ZeroEstimator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(::ZeroEstimator)(X::AbstractMatrix)</code></pre><p>Predict using the zero estimator.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractMatrix</code>: The input samples.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: Zero predictions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L359-L368">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, AdaBoostClassifier}" href="#Base.show-Tuple{IO, AdaBoostClassifier}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, model::AdaBoostClassifier)</code></pre><p>Custom show method for AdaBoostClassifier.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream.</li><li><code>model</code>::AdaBoostClassifier: The AdaBoost model to display.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L239-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, BaggingClassifier}" href="#Base.show-Tuple{IO, BaggingClassifier}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, bc::BaggingClassifier)</code></pre><p>Custom show method for BaggingClassifier.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream.</li><li><code>bc::BaggingClassifier</code>: The Bagging classifier to display.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/BaggingClassifier.jl#L245-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, GradientBoostingClassifier}" href="#Base.show-Tuple{IO, GradientBoostingClassifier}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, gbm::GradientBoostingClassifier)</code></pre><p>Custom show method for GradientBoostingClassifier.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream.</li><li><code>gbm::GradientBoostingClassifier</code>: The gradient boosting model to display.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L371-L378">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, RandomForestClassifier}" href="#Base.show-Tuple{IO, RandomForestClassifier}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, forest::RandomForestClassifier)</code></pre><p>Custom show method for RandomForestClassifier.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream.</li><li><code>forest::RandomForestClassifier</code>: The random forest classifier to display.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestClassifier.jl#L241-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, RandomForestRegressor}" href="#Base.show-Tuple{IO, RandomForestRegressor}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, forest::RandomForestRegressor)</code></pre><p>Custom show method for RandomForestRegressor.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream.</li><li><code>forest::RandomForestRegressor</code>: The random forest regressor to display.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestRegressor.jl#L247-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.show-Tuple{IO, VotingClassifier}" href="#Base.show-Tuple{IO, VotingClassifier}"><code>Base.show</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Base.show(io::IO, vc::VotingClassifier)</code></pre><p>Custom show method for VotingClassifier.</p><p><strong>Arguments</strong></p><ul><li><code>io::IO</code>: The I/O stream.</li><li><code>vc::VotingClassifier</code>: The voting classifier to display.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/VotingClassifier.jl#L203-L210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble._compute_feature_importances-Tuple{AdaBoostClassifier}" href="#NovaML.Ensemble._compute_feature_importances-Tuple{AdaBoostClassifier}"><code>NovaML.Ensemble._compute_feature_importances</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_compute_feature_importances(model::AdaBoostClassifier)</code></pre><p>Compute feature importances for the AdaBoost model.</p><p><strong>Arguments</strong></p><ul><li><code>model::AdaBoostClassifier</code>: The fitted AdaBoost model.</li></ul><p><strong>Returns</strong></p><ul><li><code>Union{Vector{Float64}, Nothing}</code>: The feature importances if available, otherwise nothing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L205-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble._compute_oob_score-Tuple{BaggingClassifier, AbstractMatrix{T} where T, AbstractVector{T} where T}" href="#NovaML.Ensemble._compute_oob_score-Tuple{BaggingClassifier, AbstractMatrix{T} where T, AbstractVector{T} where T}"><code>NovaML.Ensemble._compute_oob_score</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_compute_oob_score(bc::BaggingClassifier, X::AbstractMatrix, y::AbstractVector)</code></pre><p>Compute out-of-bag score for the Bagging classifier.</p><p><strong>Arguments</strong></p><ul><li><code>bc::BaggingClassifier</code>: The Bagging classifier.</li><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>y::AbstractVector</code>: The target values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/BaggingClassifier.jl#L183-L191">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble._generate_indices-Tuple{BaggingClassifier, Int64}" href="#NovaML.Ensemble._generate_indices-Tuple{BaggingClassifier, Int64}"><code>NovaML.Ensemble._generate_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_generate_indices(bc::BaggingClassifier, n_samples::Int)</code></pre><p>Generate sample indices for individual base estimators.</p><p><strong>Arguments</strong></p><ul><li><code>bc::BaggingClassifier</code>: The Bagging classifier.</li><li><code>n_samples</code>::Int: The number of samples in the dataset.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Int}</code>: The generated sample indices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/BaggingClassifier.jl#L220-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.bootstrap_sample-Tuple{RandomForestClassifier, AbstractMatrix{T} where T, AbstractVector{T} where T}" href="#NovaML.Ensemble.bootstrap_sample-Tuple{RandomForestClassifier, AbstractMatrix{T} where T, AbstractVector{T} where T}"><code>NovaML.Ensemble.bootstrap_sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bootstrap_sample(forest::RandomForestClassifier, X::AbstractMatrix, y::AbstractVector)</code></pre><p>Create a bootstrap sample of the dataset.</p><p><strong>Arguments</strong></p><ul><li><code>forest::RandomForestClassifier</code>: The random forest classifier.</li><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>y::AbstractVector</code>: The target values.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{AbstractMatrix, AbstractVector}</code>: The bootstrapped samples and targets.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestClassifier.jl#L188-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.calculate_tree_feature_importance-Tuple{DecisionTreeClassifier, Vector{Int64}, Int64}" href="#NovaML.Ensemble.calculate_tree_feature_importance-Tuple{DecisionTreeClassifier, Vector{Int64}, Int64}"><code>NovaML.Ensemble.calculate_tree_feature_importance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_tree_feature_importance(tree::DecisionTreeClassifier, feature_indices::Vector{Int}, n_features::Int)</code></pre><p>Calculate the feature importance for a single decision tree.</p><p><strong>Arguments</strong></p><ul><li><code>tree::DecisionTreeClassifier</code>: The decision tree.</li><li><code>feature_indices::Vector{Int}</code>: The indices of the features used in this tree.</li><li><code>n_features::Int</code>: The total number of features.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The feature importances.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestClassifier.jl#L210-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.compute_feature_importances-Tuple{GradientBoostingClassifier}" href="#NovaML.Ensemble.compute_feature_importances-Tuple{GradientBoostingClassifier}"><code>NovaML.Ensemble.compute_feature_importances</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_feature_importances(gbm::GradientBoostingClassifier)</code></pre><p>Compute feature importances for the gradient boosting model.</p><p><strong>Arguments</strong></p><ul><li><code>gbm::GradientBoostingClassifier</code>: The fitted gradient boosting model.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: The feature importances.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L289-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.compute_loss-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, String}" href="#NovaML.Ensemble.compute_loss-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, String}"><code>NovaML.Ensemble.compute_loss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_loss(y::AbstractVector, y_pred::AbstractVector, loss::String)</code></pre><p>Compute the loss for the given predictions.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: The true values.</li><li><code>y_pred</code>::AbstractVector: The predicted values.</li><li><code>loss::String</code>: The loss function name.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The computed loss.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L265-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.compute_negative_gradient-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, String}" href="#NovaML.Ensemble.compute_negative_gradient-Tuple{AbstractVector{T} where T, AbstractVector{T} where T, String}"><code>NovaML.Ensemble.compute_negative_gradient</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_negative_gradient(y::AbstractVector, y_pred::AbstractVector, loss::String)</code></pre><p>Compute negative gradient for the given loss function.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: The true values.</li><li><code>y_pred::AbstractVector</code>: The predicted values.</li><li><code>loss::String</code>: The loss function name.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector</code>: The negative gradient.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L243-L254">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.compute_oob_score-Tuple{RandomForestRegressor, AbstractMatrix{T} where T, AbstractVector{T} where T}" href="#NovaML.Ensemble.compute_oob_score-Tuple{RandomForestRegressor, AbstractMatrix{T} where T, AbstractVector{T} where T}"><code>NovaML.Ensemble.compute_oob_score</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_oob_score(forest::RandomForestRegressor, X::AbstractMatrix, y::AbstractVector)</code></pre><p>Compute out-of-bag (OOB) score for the random forest regressor.</p><p><strong>Arguments</strong></p><ul><li><code>forest::RandomForestRegressor</code>: The random forest regressor.</li><li><code>X::AbstractMatrix</code>: The input samples.</li><li><code>y::AbstractVector</code>: The target values.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Float64, Vector{Float64}}</code>: The OOB score and OOB predictions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestRegressor.jl#L220-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.decision_function-Tuple{AdaBoostClassifier, AbstractMatrix{T} where T}" href="#NovaML.Ensemble.decision_function-Tuple{AdaBoostClassifier, AbstractMatrix{T} where T}"><code>NovaML.Ensemble.decision_function</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">decision_function(model::AdaBoostClassifier, X::AbstractMatrix)</code></pre><p>Compute the decision function of X.</p><p><strong>Arguments</strong></p><ul><li><code>model::AdaBoostClassifier</code>: The fitted AdaBoost model.</li><li><code>X::AbstractMatrix</code>: The input samples.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float64}</code>: The decision function of the input samples.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L315-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.fit_initial_estimator-Tuple{AbstractVector{T} where T}" href="#NovaML.Ensemble.fit_initial_estimator-Tuple{AbstractVector{T} where T}"><code>NovaML.Ensemble.fit_initial_estimator</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fit_initial_estimator(y::AbstractVector)</code></pre><p>Fit an initial estimator based on the mean of y.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: The target values.</li></ul><p><strong>Returns</strong></p><ul><li><code>InitialEstimator</code>: The fitted initial estimator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/GradientBoostingClassifier.jl#L338-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.get_max_features-Tuple{RandomForestClassifier, Int64}" href="#NovaML.Ensemble.get_max_features-Tuple{RandomForestClassifier, Int64}"><code>NovaML.Ensemble.get_max_features</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_max_features(forest::RandomForestClassifier, n_features::Int)</code></pre><p>Get the number of features to consider when looking for the best split.</p><p><strong>Arguments</strong></p><ul><li><code>forest::RandomForestClassifier</code>: The random forest classifier.</li><li><code>n_features::Int</code>: The total number of features.</li></ul><p>Returns</p><ul><li><code>Int</code>: The number of features to consider.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestClassifier.jl#L161-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.get_max_features-Tuple{RandomForestRegressor, Int64}" href="#NovaML.Ensemble.get_max_features-Tuple{RandomForestRegressor, Int64}"><code>NovaML.Ensemble.get_max_features</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>get<em>max</em>features(forest::RandomForestRegressor, n_features::Int) Get the number of features to consider when looking for the best split.</p><p><strong>Arguments</strong></p><ul><li><code>forest::RandomForestRegressor</code>: The random forest regressor.</li><li><code>n_features::Int</code>: The total number of features.</li></ul><p><strong>Returns</strong></p><p><strong><code>Int</code>: The number of features to consider.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/RandomForestRegressor.jl#L193-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.get_params-Tuple{AdaBoostClassifier}" href="#NovaML.Ensemble.get_params-Tuple{AdaBoostClassifier}"><code>NovaML.Ensemble.get_params</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_params(model::AdaBoostClassifier; deep=true)</code></pre><p>Get parameters for this estimator.</p><p><strong>Arguments</strong></p><ul><li><code>model::AdaBoostClassifier</code>: The AdaBoost model.</li><li><code>deep::Bool</code>: If true, will return the parameters for this estimator and contained subobjects that are estimators.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict</code>: Parameter names mapped to their values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L258-L268">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.set_params!-Tuple{AdaBoostClassifier}" href="#NovaML.Ensemble.set_params!-Tuple{AdaBoostClassifier}"><code>NovaML.Ensemble.set_params!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_params!(model::AdaBoostClassifier; kwargs...)</code></pre><p>Set the parameters of this estimator.</p><p><strong>Arguments</strong></p><ul><li><code>model::AdaBoostClassifier</code>: The AdaBoost model.</li><li><code>kwargs...</code>: Estimator parameters.</li></ul><p><strong>Returns</strong></p><ul><li><code>AdaBoostClassifier</code>: The estimator instance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L286-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.staged_predict-Tuple{AdaBoostClassifier, AbstractMatrix{T} where T}" href="#NovaML.Ensemble.staged_predict-Tuple{AdaBoostClassifier, AbstractMatrix{T} where T}"><code>NovaML.Ensemble.staged_predict</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">staged_predict(model::AdaBoostClassifier, X::AbstractMatrix)</code></pre><p>Return a generator of predictions for each boosting iteration.</p><p><strong>Arguments</strong></p><ul><li><code>model::AdaBoostClassifier</code>: The fitted AdaBoost model.</li><li><code>X::AbstractMatrix</code>: The input samples.</li></ul><p><strong>Returns</strong></p><ul><li><code>Channel</code>: A generator of predictions at each stage.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L351-L361">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.staged_predict_proba-Tuple{AdaBoostClassifier, AbstractMatrix{T} where T}" href="#NovaML.Ensemble.staged_predict_proba-Tuple{AdaBoostClassifier, AbstractMatrix{T} where T}"><code>NovaML.Ensemble.staged_predict_proba</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">staged_predict_proba(model::AdaBoostClassifier, X::AbstractMatrix)</code></pre><p>Return a generator of predicted probabilities for each boosting iteration.</p><p><strong>Arguments</strong></p><ul><li><code>model::AdaBoostClassifier</code>: The fitted AdaBoost model.</li><li><code>X::AbstractMatrix</code>: The input samples.</li></ul><p><strong>Returns</strong></p><ul><li><code>Channel</code>: A generator of predicted probabilities at each stage.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/AdaBoostClassifier.jl#L388-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="NovaML.Ensemble.transform-Tuple{VotingClassifier, AbstractMatrix{T} where T}" href="#NovaML.Ensemble.transform-Tuple{VotingClassifier, AbstractMatrix{T} where T}"><code>NovaML.Ensemble.transform</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transform(vc::VotingClassifier, X::AbstractMatrix)</code></pre><p>Return class labels or probabilities for X for each estimator.</p><p><strong>Arguments</strong></p><ul><li><code>vc::VotingClassifier</code>: The fitted voting classifier.</li><li><code>X::AbstractMatrix</code>: The input samples.</li></ul><p><strong>Returns</strong></p><ul><li>If <code>voting</code> is <code>:soft</code>, returns the probabilities for each class for each estimator.</li><li>If <code>voting</code> is <code>:hard</code>, returns the class label predictions of each estimator.</li></ul><p>The shape of the return depends on the <code>flatten_transform</code> parameter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ilkerarslan/NovaML.jl/blob/12190e8b3c2e6554851ca7d2ca23e9ff9ae55718/src/Ensemble/VotingClassifier.jl#L161-L174">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/dimensionality_reduction/">« Dimensionality Reduction</a><a class="docs-footer-nextpage" href="../contribute/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.6.0 on <span class="colophon-date" title="Sunday 1 September 2024 19:42">Sunday 1 September 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
