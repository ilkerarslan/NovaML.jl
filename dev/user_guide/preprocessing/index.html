<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Preprocessing · NovaML.jl</title><meta name="title" content="Data Preprocessing · NovaML.jl"/><meta property="og:title" content="Data Preprocessing · NovaML.jl"/><meta property="twitter:title" content="Data Preprocessing · NovaML.jl"/><meta name="description" content="Documentation for NovaML.jl."/><meta property="og:description" content="Documentation for NovaML.jl."/><meta property="twitter:description" content="Documentation for NovaML.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NovaML.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../core_concepts/">Core Concepts</a></li><li class="is-active"><a class="tocitem" href>Data Preprocessing</a><ul class="internal"><li><a class="tocitem" href="#Scaling"><span>Scaling</span></a></li><li><a class="tocitem" href="#Encoding"><span>Encoding</span></a></li><li><a class="tocitem" href="#Imputation"><span>Imputation</span></a></li><li><a class="tocitem" href="#Pipelines"><span>Pipelines</span></a></li><li><a class="tocitem" href="#Text-Preprocessing"><span>Text Preprocessing</span></a></li></ul></li><li><a class="tocitem" href="../model_training/">Model Training</a></li><li><a class="tocitem" href="../model_evaluation/">Model Evaluation</a></li><li><a class="tocitem" href="../feature_engineering/">Feature Engineering</a></li><li><a class="tocitem" href="../pipelines/">Pipelines</a></li><li><a class="tocitem" href="../hyperparameter_tuning/">Hyperparameter Tuning</a></li><li><a class="tocitem" href="../cross_validation/">Cross-Validation</a></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../models/linear_models/">Linear Models</a></li><li><a class="tocitem" href="../../models/tree_models/">Tree-Based Models</a></li><li><a class="tocitem" href="../../models/ensemble_methods/">Ensemble Methods</a></li><li><a class="tocitem" href="../../models/svm/">Support Vector Machines</a></li><li><a class="tocitem" href="../../models/clustering/">Clustering</a></li><li><a class="tocitem" href="../../models/dimensionality_reduction/">Dimensionality Reduction</a></li></ul></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><a class="tocitem" href="../../contribute/">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Data Preprocessing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data Preprocessing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ilkerarslan/NovaML.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ilkerarslan/NovaML.jl/blob/master/docs/src/user_guide/preprocessing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Preprocessing"><a class="docs-heading-anchor" href="#Data-Preprocessing">Data Preprocessing</a><a id="Data-Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Preprocessing" title="Permalink"></a></h1><p>Data preprocessing is a crucial step in any machine learning pipeline. NovaML.jl provides a range of tools for cleaning, transforming, and preparing your data for model training. This page covers the main preprocessing techniques available in NovaML.</p><h2 id="Scaling"><a class="docs-heading-anchor" href="#Scaling">Scaling</a><a id="Scaling-1"></a><a class="docs-heading-anchor-permalink" href="#Scaling" title="Permalink"></a></h2><p>Scaling features is often necessary to ensure that all features contribute equally to the model training process. NovaML offers several scaling methods:</p><h3 id="StandardScaler"><a class="docs-heading-anchor" href="#StandardScaler">StandardScaler</a><a id="StandardScaler-1"></a><a class="docs-heading-anchor-permalink" href="#StandardScaler" title="Permalink"></a></h3><p>Standardizes features by removing the mean and scaling to unit variance.</p><pre><code class="language-julia hljs">using NovaML.Datasets
iris = load_iris()
X = iris[&quot;data&quot;][:, 3:4]
y = iris[&quot;target&quot;]</code></pre><p>Split data to train and test sets.</p><pre><code class="language-julia hljs">using NovaML.ModelSelection
Xtrn, Xtst, ytrn, ytst = train_test_split(X, y, test_size=0.3, stratify=y)</code></pre><p>Fit and transform <code>StandardScaler</code>.</p><pre><code class="language-julia hljs">using NovaML.PreProcessing

stdscaler = StandardScaler()

# fit and transform
Xtrnstd = stdscaler(Xtrn)

# transform
Xtststd = stdscaler(Xtst)

# inverse transform
Xtrn = stdscaler(Xtrnstd, type=:inverse)</code></pre><h3 id="MinMaxScaler"><a class="docs-heading-anchor" href="#MinMaxScaler">MinMaxScaler</a><a id="MinMaxScaler-1"></a><a class="docs-heading-anchor-permalink" href="#MinMaxScaler" title="Permalink"></a></h3><p>Scales features to a number between [0, 1].</p><pre><code class="language-julia hljs">minmax = MinMaxScaler()

# fit &amp; transform
Xtrn_mm = minmax(Xtrn)
# transform
Xtst_mm = minmax(Xtst)
# inverse transform
Xtrn = minmax(Xtrn_mm, type=:inverse)</code></pre><h2 id="Encoding"><a class="docs-heading-anchor" href="#Encoding">Encoding</a><a id="Encoding-1"></a><a class="docs-heading-anchor-permalink" href="#Encoding" title="Permalink"></a></h2><p>Categorical variables often need to be encoded into numerical form for machine learning algorithms.</p><h3 id="LabelEncoder"><a class="docs-heading-anchor" href="#LabelEncoder">LabelEncoder</a><a id="LabelEncoder-1"></a><a class="docs-heading-anchor-permalink" href="#LabelEncoder" title="Permalink"></a></h3><p>Encodes target labels with value between 0 and n_classes-1.</p><pre><code class="language-julia hljs">using NovaML.PreProcessing

lblencode = LabelEncoder()

labels = [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;M&quot;, &quot;L&quot;, &quot;M&quot;]

# Label encode labels
labels = lblencode(labels)

# Get the labels back
lblencode(labels, :inverse)</code></pre><h3 id="OneHotEncoder"><a class="docs-heading-anchor" href="#OneHotEncoder">OneHotEncoder</a><a id="OneHotEncoder-1"></a><a class="docs-heading-anchor-permalink" href="#OneHotEncoder" title="Permalink"></a></h3><p>Encodes categorical features as a one-hot numeric array.</p><pre><code class="language-julia hljs">using NovaML.PreProcessing

labels = [&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;M&quot;, &quot;L&quot;, &quot;M&quot;]

ohe = OneHotEncoder()
onehot = ohe(labels)
ohe(onehot, :inverse)</code></pre><h3 id="PolynomialFeatures"><a class="docs-heading-anchor" href="#PolynomialFeatures">PolynomialFeatures</a><a id="PolynomialFeatures-1"></a><a class="docs-heading-anchor-permalink" href="#PolynomialFeatures" title="Permalink"></a></h3><p>Generates polynomial and interaction features.</p><pre><code class="language-julia hljs">using NovaML.PreProcessing

X = rand(5, 2)
# 5×2 Matrix{Float64}:
#  0.85245   0.405935
#  0.139957  0.380467
#  0.730332  0.0418465
#  0.051091  0.570372
#  0.730245  0.128763

poly = PolynomialFeatures(
    degree=2,
    interaction_only=false,
    include_bias=true)

Xnew = poly(X)
# 5×6 Matrix{Float64}:
#  1.0  0.85245   0.405935   0.72667     0.346039   0.164783
#  1.0  0.139957  0.380467   0.0195881   0.0532491  0.144755
#  1.0  0.730332  0.0418465  0.533384    0.0305618  0.00175113
#  1.0  0.051091  0.570372   0.00261029  0.0291409  0.325324
#  1.0  0.730245  0.128763   0.533258    0.0940282  0.0165798</code></pre><h2 id="Imputation"><a class="docs-heading-anchor" href="#Imputation">Imputation</a><a id="Imputation-1"></a><a class="docs-heading-anchor-permalink" href="#Imputation" title="Permalink"></a></h2><p>Missing data is a common issue in real-world datasets. NovaML provides tools for handling missing values. The <code>strategy</code> argument must be one of <code>:mean</code>, <code>:median</code>, <code>:most_frequent</code>, or <code>:constant</code>.</p><h3 id="SimpleImputer"><a class="docs-heading-anchor" href="#SimpleImputer">SimpleImputer</a><a id="SimpleImputer-1"></a><a class="docs-heading-anchor-permalink" href="#SimpleImputer" title="Permalink"></a></h3><p>Imputes missing values using a variety of strategies.</p><pre><code class="language-julia hljs">X = [1.0   2.0   3.0       4.0
     5.0   6.0    missing  8.0
    10.0  11.0  12.0        missing]

using NovaML.Impute
imputer = SimpleImputer(strategy=:mean)
Ximp = imputer(X)

# 3×4 Matrix{Union{Missing, Float64}}:
#   1.0   2.0   3.0  4.0
#   5.0   6.0   7.5  8.0
#  10.0  11.0  12.0  6.0</code></pre><h2 id="Pipelines"><a class="docs-heading-anchor" href="#Pipelines">Pipelines</a><a id="Pipelines-1"></a><a class="docs-heading-anchor-permalink" href="#Pipelines" title="Permalink"></a></h2><p>You can combine multiple preprocessing steps into a single pipeline for easier management and application.</p><pre><code class="language-julia hljs">using NovaML.PreProcessing: StandardScaler
using NovaML.Decomposition: PCA
using NovaML.LinearModel: LogisticRegression

sc = StandardScaler()
pca = PCA(n_components=2)
lr = LogisticRegression()

# transform the data and fit the model 
Xtrn |&gt; sc |&gt; pca |&gt; X -&gt; lr(X, ytrn)

# make predictions
ŷtst = Xtst |&gt; sc |&gt; pca |&gt; lr</code></pre><p>It is also possible to create pipelines using NovaML&#39;s <code>Pipe</code> constructor:</p><pre><code class="language-julia hljs">using NovaML.Pipelines: pipe

# create a pipeline
pipe = pipe(
   StandardScaler(),
   PCA(n_components=2),
   LogisticRegression())

# fit the pipe
pipe(Xtrn, ytrn)
# make predictions
ŷ = pipe(Xtst) 
# make probability predictions
ŷprobs = pipe(Xtst, type=:probs)</code></pre><h2 id="Text-Preprocessing"><a class="docs-heading-anchor" href="#Text-Preprocessing">Text Preprocessing</a><a id="Text-Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Text-Preprocessing" title="Permalink"></a></h2><p>For text data, NovaML offers vectorization techniques:</p><h3 id="CountVectorizer"><a class="docs-heading-anchor" href="#CountVectorizer">CountVectorizer</a><a id="CountVectorizer-1"></a><a class="docs-heading-anchor-permalink" href="#CountVectorizer" title="Permalink"></a></h3><p>Converts a collection of text documents to a matrix of token counts.</p><pre><code class="language-julia hljs">docs = [
    &quot;Julia was designed for high performance&quot;,
    &quot;Julia uses multiple dispatch as a paradigm&quot;,
    &quot;Julia is dynamically typed, feels like a scripting language&quot;,
    &quot;But can also optionally be separately compiled&quot;,
    &quot;Julia is an open source project&quot;];

using NovaML.FeatureExtraction

countvec = CountVectorizer();
bag = countvec(docs);
countvec.vocabulary

# Dict{String, Int64} with 30 entries:
#   &quot;scripting&quot;   =&gt; 25
#   &quot;high&quot;        =&gt; 14
#   &quot;feels&quot;       =&gt; 12
#   &quot;is&quot;          =&gt; 15
#   &quot;separately&quot;  =&gt; 26
#   &quot;language&quot;    =&gt; 17
#   &quot;typed&quot;       =&gt; 28
#   &quot;but&quot;         =&gt; 6
#   &quot;a&quot;           =&gt; 1
#   &quot;for&quot;         =&gt; 13
#   &quot;optionally&quot;  =&gt; 21
#   &quot;paradigm&quot;    =&gt; 22
#   &quot;was&quot;         =&gt; 30
#   &quot;dynamically&quot; =&gt; 11
#   &quot;also&quot;        =&gt; 2
#   &quot;an&quot;          =&gt; 3
#   &quot;multiple&quot;    =&gt; 19
#   &quot;be&quot;          =&gt; 5
#   &quot;julia&quot;       =&gt; 16
#   &quot;project&quot;     =&gt; 24
#   &quot;uses&quot;        =&gt; 29
#   &quot;source&quot;      =&gt; 27
#   &quot;open&quot;        =&gt; 20
#   &quot;performance&quot; =&gt; 23
#   &quot;compiled&quot;    =&gt; 8
#   &quot;designed&quot;    =&gt; 9
#   &quot;as&quot;          =&gt; 4
#   &quot;can&quot;         =&gt; 7
#   &quot;like&quot;        =&gt; 18
#   &quot;dispatch&quot;    =&gt; 10

countvec(bag, type=:inverse)
# 5-element Vector{String}:
#  &quot;designed for high julia performance was&quot;
#  &quot;a as dispatch julia multiple paradigm uses&quot;
#  &quot;a dynamically feels is julia language like scripting typed&quot;      
#  &quot;also be but can compiled optionally separately&quot;
#  &quot;an is julia open project source&quot;</code></pre><h3 id="TfidfVectorizer"><a class="docs-heading-anchor" href="#TfidfVectorizer">TfidfVectorizer</a><a id="TfidfVectorizer-1"></a><a class="docs-heading-anchor-permalink" href="#TfidfVectorizer" title="Permalink"></a></h3><p>Converts a collection of raw documents to a matrix of TF-IDF features.</p><pre><code class="language-julia hljs">tfidf = TfidfVectorizer()

result = tfidf(docs)
tfidf.vocabulary
tfidf(result, type=:inverse)

new_docs = [&quot; The talk on the Unreasonable Effectiveness of Multiple Dispatch explains why it works so well.&quot;]
Xnew = tfidf(new_docs)
</code></pre><p>Most preprocessing transforms in NovaML follow the functor pattern: transform(X) both fits the transformer to the data and applies the transformation. For separate fitting and transforming (e.g., when you want to apply the same transformation to test data), you can use the fitted transformer directly on new data.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../core_concepts/">« Core Concepts</a><a class="docs-footer-nextpage" href="../model_training/">Model Training »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Friday 6 September 2024 08:06">Friday 6 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
